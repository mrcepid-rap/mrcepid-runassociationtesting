import tarfile

from os.path import exists
from typing import TypedDict

from runassociationtesting.burden.loader import BurdenProgramArgs
from runassociationtesting.ingest_data import *


# A TypedDict holding information about each chromosome's available genetic data
class BGENInformation(TypedDict):
    index: str
    sample: str
    bgen: str
    vep: str


class BurdenAssociationPack(AssociationPack):

    def __init__(self, association_pack: AssociationPack,
                 is_snp_tar: bool, is_gene_tar: bool, tarball_prefixes: List[str],
                 bgen_dict: Dict[str, BGENInformation], run_marker_tests: bool):

        super().__init__(association_pack.pheno_files, association_pack.inclusion_found,
                         association_pack.exclusion_found, association_pack.additional_covariates_found,
                         association_pack.is_binary, association_pack.sex, association_pack.threads,
                         association_pack.pheno_names,
                         association_pack.found_quantitative_covariates, association_pack.found_categorical_covariates)

        self.is_snp_tar = is_snp_tar
        self.is_gene_tar = is_gene_tar
        self.is_non_standard_tar = is_snp_tar or is_gene_tar
        self.tarball_prefixes = tarball_prefixes
        self.bgen_dict = bgen_dict
        self.run_marker_tests = run_marker_tests


class BurdenIngestData(IngestData):

    def __init__(self, parsed_options: BurdenProgramArgs):
        super().__init__(parsed_options)

        # Put additional options/covariate processing required by this specific package here
        if len(self.get_association_pack().pheno_names) > 1:
            raise dxpy.AppError('The burden module currently only allows for running one phenotype at a time!')

        is_snp_tar, is_gene_tar, tarball_prefixes = self._ingest_tarballs(parsed_options.association_tarballs)
        bgen_dict = self._ingest_bgen(parsed_options.bgen_index)

        self._ingest_genetic_data(parsed_options.array_bed_file,
                                  parsed_options.array_fam_file,
                                  parsed_options.array_bim_file,
                                  parsed_options.low_MAC_list,
                                  parsed_options.sparse_grm,
                                  parsed_options.sparse_grm_sample)

        # Put additional covariate processing specific to this module here
        self.set_association_pack(BurdenAssociationPack(self.get_association_pack(),
                                                        is_snp_tar, is_gene_tar, tarball_prefixes,
                                                        bgen_dict, parsed_options.run_marker_tests))

    # Need to grab the tarball file for associations...
    # This was generated by the applet mrcepid-collapsevariants
    # Ingest the list file into this AWS instance
    @staticmethod
    def _ingest_tarballs(association_tarballs: dxpy.DXFile) -> Tuple[bool, bool, List[str]]:

        is_snp_tar = False
        is_gene_tar = False
        tarball_prefixes = []
        if '.tar.gz' in association_tarballs.describe()['name']:
            # likely to be a single tarball, download, check, and extract:
            tarball_name = association_tarballs.describe()['name']
            dxpy.download_dxfile(association_tarballs, tarball_name)
            if tarfile.is_tarfile(tarball_name):
                tarball_prefix = tarball_name.replace(".tar.gz", "")
                tarball_prefixes.append(tarball_prefix)
                tar = tarfile.open(tarball_name, "r:gz")
                tar.extractall()
                if exists(tarball_prefix + ".SNP.BOLT.bgen"):
                    is_snp_tar = True
                elif exists(tarball_prefix + ".GENE.BOLT.bgen"):
                    is_gene_tar = True
            else:
                raise dxpy.AppError(f'Provided association tarball ({association_tarballs.describe()["id"]}) '
                                    f'is not a tar.gz file')
        else:
            # Likely to be a list of tarballs, download and extract...
            dxpy.download_dxfile(association_tarballs, "tarball_list.txt")
            with open("tarball_list.txt", "r") as tarball_reader:
                for association_tarball in tarball_reader:
                    association_tarball = association_tarball.rstrip()
                    tarball = dxpy.DXFile(association_tarball)
                    tarball_name = tarball.describe()['name']
                    dxpy.download_dxfile(tarball, tarball_name)

                    # Need to get the prefix on the tarball to access resources within:
                    # All files within SHOULD have the same prefix as this file
                    tarball_prefix = tarball_name.rstrip('.tar.gz')
                    tarball_prefixes.append(tarball_prefix)
                    tar = tarfile.open(tarball_name, "r:gz")
                    tar.extractall()
                    if exists(tarball_prefix + ".SNP.BOLT.bgen"):
                        raise dxpy.AppError(f'Cannot run masks from a SNP list ({association_tarballs.describe()["id"]}) '
                                            f'when running tarballs as batch...')
                    elif exists(tarball_prefix + ".GENE.BOLT.bgen"):
                        raise dxpy.AppError(f'Cannot run masks from a GENE list ({association_tarballs.describe()["id"]}) '
                                            f'when running tarballs as batch...')

        return is_snp_tar, is_gene_tar, tarball_prefixes

    # Grab the entire WES variant data in bgen format
    @staticmethod
    def _ingest_bgen(bgen_index: dxpy.DXFile) -> Dict[str, BGENInformation]:

        # Ingest the INDEX of bgen files:
        dxpy.download_dxfile(bgen_index.get_id(), "bgen_locs.tsv")
        # and load it into a dict:
        os.mkdir("filtered_bgen/")  # For downloading later...
        bgen_index_csv = csv.DictReader(open("bgen_locs.tsv", "r"), delimiter="\t")
        bgen_dict = {}
        for line in bgen_index_csv:
            bgen_dict[line['chrom']] = {'index': line['bgen_index_dxid'],
                                        'sample': line['sample_dxid'],
                                        'bgen': line['bgen_dxid'],
                                        'vep': line['vep_dxid']}
        return bgen_dict

    @staticmethod
    def _ingest_genetic_data(bed_file: dxpy.DXFile, fam_file: dxpy.DXFile, bim_file: dxpy.DXFile,
                             low_mac_list: dxpy.DXFile,
                             sparse_grm: dxpy.DXFile, sparse_grm_sample: dxpy.DXFile) -> None:
        # Now grab all genetic data that I have in the folder /project_resources/genetics/
        os.mkdir("genetics/")  # This is for legacy reasons to make sure all tests work...
        dxpy.download_dxfile(bed_file.get_id(), 'genetics/UKBB_470K_Autosomes_QCd.bed')
        dxpy.download_dxfile(bim_file.get_id(), 'genetics/UKBB_470K_Autosomes_QCd.bim')
        dxpy.download_dxfile(fam_file.get_id(), 'genetics/UKBB_470K_Autosomes_QCd.fam')
        dxpy.download_dxfile(low_mac_list.get_id(), 'genetics/UKBB_470K_Autosomes_QCd.low_MAC.snplist')
        # This is the sparse matrix
        dxpy.download_dxfile(sparse_grm.get_id(),
                             'genetics/sparseGRM_470K_Autosomes_QCd.sparseGRM.mtx')
        dxpy.download_dxfile(sparse_grm_sample.get_id(),
                             'genetics/sparseGRM_470K_Autosomes_QCd.sparseGRM.mtx.sampleIDs.txt')
