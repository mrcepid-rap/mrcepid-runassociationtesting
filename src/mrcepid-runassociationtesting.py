#!/usr/bin/env python
# mrcepid-runnassociationtesting 0.0.1
# Generated by dx-app-wizard.
#
# Author: Eugene Gardner (eugene.gardner at mrc.epid.cam.ac.uk)
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import dxpy
import csv
import subprocess
import tarfile
import pandas as pd
import statsmodels.api as sm
import numpy as np


# This function runs a command on an instance, either with or without calling the docker instance we downloaded
# By default, commands are not run via Docker, but can be changed by setting is_docker = True
def run_cmd(cmd: str, is_docker: bool = False) -> None:

    # -v here mounts a local directory on an instance (in this case the home dir) to a directory internal to the
    # Docker instance named /test/. This allows us to run commands on files stored on the AWS instance within Docker.
    # This looks slightly different from other versions of this command I have written as I needed to write a custom
    # R script to run STAAR. That means we have multiple mounts here to enable this code to find the script.
    if is_docker:
        cmd = "docker run " \
              "-v /home/dnanexus:/test " \
              "-v /usr/bin/:/prog " \
              "egardner413/mrcepid-associationtesting " + cmd

    # Standard python calling external commands protocol
    print(cmd)
    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = proc.communicate()

    # If the command doesn't work, print the error stream and close the AWS instance out with 'dxpy.AppError'
    if proc.returncode != 0:
        print("The following cmd failed:")
        print(cmd)
        print("STDERROR follows\n")
        print(stderr.decode('utf-8'))
        raise dxpy.AppError("Failed to run properly...")


# This function is slightly different that in other applets I have designed. This function handles ALL inputs rather
# than just external dependencies
def ingest_data(association_tarball: str, phenofile: str) -> str:

    # Need to grab the tarball file for associations...
    # This was generated by the applet mrcepid-mergecollapsevariants
    tarball = dxpy.DXFile(association_tarball)
    tarball_name = tarball.describe()['name']
    dxpy.download_dxfile(tarball, tarball_name)

    # Need to get the prefix on the tarball to access resources within:
    # All files within SHOULD have the same prefix as this file
    tarball_prefix = tarball_name.rstrip('.tar.gz')
    cmd = "tar -zxf " + tarball_name # unzip the tarball:
    run_cmd(cmd)

    # Now grab all genetic data that I have in the folder /project_resources/genetics/
    # This includes filtered plink files and masks
    # This was generated by mrcepid-buildgrms
    dxpy.download_folder('project-G2XK5zjJXk83yZ598Z7BpGPk',
                         'genetics/',
                         folder = "/project_resources/genetics/")

    # Get phenotype data:
    dxpy.download_dxfile('file-G529v8jJxQq1jgxx4gbPpPQj', 'covariates.tsv')
    dxpy.download_dxfile(phenofile, 'model_phenotypes.pheno')

    return tarball_prefix


# Do covariate processing and sample inclusion/exclusion
def process_covariates(sex: int) -> str:

    # First write individuals that we are going to exclude (bolt requires this):
    # And get a list of individuals that we are NOT going to use
    to_exclude = set()
    exclude_file = open('genetics/EXCLUDEFOR_White_Euro_Relateds.txt', 'r')
    for indv in exclude_file:
        indv = indv.rstrip()
        to_exclude.add(indv)
        sample = {'FID': indv, 'IID': indv}

    # Get individuals with genetic data
    # Remember! the genetic data has already been filtered to individuals with WES data.
    genetics_fam_file = open('genetics/UKBB_200K_Autosomes_QCd.fam', 'r')
    genetics_samples = set()
    for line in genetics_fam_file:
        line = line.rstrip()
        fields = line.split()
        eid = fields[0]
        genetics_samples.add(eid)

    # Need to go through phenofile first and injest into a dictionary and get the name of the phenofield:
    pheno_reader = csv.DictReader(open('model_phenotypes.pheno', 'r'), delimiter="\t")
    field_names = pheno_reader.fieldnames
    if len(field_names) != 3:
        raise RuntimeError("Pheno file has more than three columns!")
    elif "FID" not in field_names and "IID" not in field_names:
        raise RuntimeError("Pheno file has column names other than FID/IID/Phenotype!")

    for field in field_names:
        if field != "FID" and field != "IID":
            pheno_name = field

    phenotypes = {}
    for indv in pheno_reader:
        # Will spit out an error if a given sample does not have data
        if indv[pheno_name] is None:
            raise dxpy.AppError("Phenotype file has blank lines!")
        # Exclude individuals that have missing data (NA/NAN)
        elif indv[pheno_name].lower() != "na" or indv[pheno_name].lower() != "nan":
            phenotypes[indv['FID']] = indv[pheno_name]

    # Read the covariates into this code that we want to analyse:
    covar_reader = csv.DictReader(open('covariates.tsv', 'r'), delimiter="\t")
    indv_written = 0 # Just to count the number of samples we will analyse
    formatted_combo_file = open('phenotypes_covariates.formatted.txt', 'w') # SAIGE needs a combo file

    write_fields = ["FID", "IID"]
    write_fields = write_fields + ["PC%s" % (x) for x in range(1,41)]
    write_fields = write_fields + ["age", "sex", "batch"]
    write_fields = write_fields + [pheno_name]
    combo_writer = csv.DictWriter(formatted_combo_file,
                                  fieldnames = write_fields,
                                  quoting = csv.QUOTE_NONE,
                                  delimiter = " ",
                                  extrasaction='ignore')
    combo_writer.writeheader()

    # Need a list of included individuals ONLY:
    include_samples = open('SAMPLES_Include.txt', 'w')

    for indv in covar_reader:
        if indv['22001-0.0'] != "": # need to exclude blank row individuals, eid is normally the only thing that shows up, so filter on sex
            indv_writer = {'FID': indv['eid'],
                           'IID': indv['eid']}
            for PC in range(1,41):
                old_PC = "22009-0.%s" % (PC)
                new_pc = "PC%s" % (PC)
                indv_writer[new_pc] = indv[old_PC]
            indv_writer['age'] = indv['21003-0.0']
            indv_writer['sex'] = int(indv['22001-0.0'])
            indv_writer['batch'] = indv['22000-0.0']
            # exclude based on sex-specific analysis if required:
            if indv['eid'] in phenotypes:
                indv_writer[pheno_name] = phenotypes[indv['eid']]
                if indv['eid'] not in to_exclude and indv['eid'] in genetics_samples:
                    if sex == 2:
                        indv_written += 1
                        combo_writer.writerow(indv_writer)
                        include_samples.write(indv['eid'] + "\n")
                    elif sex == indv_writer['sex']:
                        indv_written += 1
                        combo_writer.writerow(indv_writer)
                        include_samples.write(indv['eid'] + "\n")

    formatted_combo_file.close()
    include_samples.close()

    # Generate a plink file to use that only has included individuals:
    cmd = "plink2 " \
          "--bfile /test/genetics/UKBB_200K_Autosomes_QCd --make-bed --keep-fam /test/SAMPLES_Include.txt " \
          "--out /test/genetics/UKBB_200K_Autosomes_QCd_WBA"
    run_cmd(cmd, True)

    # I have to do this to recover the sample information from plink
    cmd = "docker run -v /home/dnanexus/:/test/ egardner413/mrcepid-associationtesting plink2 " \
          "--bfile /test/genetics/UKBB_200K_Autosomes_QCd_WBA " \
          "--validate | grep samples"
    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = proc.communicate()

    # Print to ensure that total number of individuals is consistent between genetic and covariate/phenotype data
    print("Number of individuals written to covariate/pheno file: %i" % indv_written)
    print("Plink individuals information                        : %s" % stdout.decode('utf-8').rstrip())

    return pheno_name # Return the phenotype name so we can use it later


# Run rare variant association testing using BOLT
def bolt(tarball_prefix: str, pheno_name: str) -> None:

    # Need to pare down the bgen file to samples being tested
    cmd = "plink2 --bgen /test/PTV.BOLT.bgen 'ref-last' --sample /test/PTV.BOLT.sample --export bgen-1.2 'bits='8 --out /test/bolt_input --keep-fam /test/SAMPLES_Include.txt"
    run_cmd(cmd, True)

    # See the README.md for more information on these parameters
    cmd = "bolt " + \
          "--bfile=/test/genetics/UKBB_200K_Autosomes_QCd_WBA " \
          "--exclude=/test/genetics/UKBB_200K_Autosomes_QCd.low_MAC.snplist " \
          "--phenoFile=/test/phenotypes_covariates.formatted.txt " \
          "--phenoCol=" + pheno_name + " " \
          "--covarFile=/test/phenotypes_covariates.formatted.txt " \
          "--covarCol=batch " \
          "--covarCol=sex " \
          "--qCovarCol=age " \
          "--qCovarCol=PC{1:10} " \
          "--covarMaxLevels=110 " \
          "--LDscoresFile=BOLT-LMM_v2.3.5/tables/LDSCORE.1000G_EUR.tab.gz " \
          "--geneticMapFile=BOLT-LMM_v2.3.5/tables/genetic_map_hg19_withX.txt.gz " \
          "--lmmInfOnly " \
          "--numThreads=32 " \
          "--statsFile=/test/" + tarball_prefix + ".stats.gz " \
          "--verboseStats " \
          "--bgenFile=/test/bolt_input.bgen " \
          "--sampleFile=/test/bolt_input.sample " \
          "--statsFileBgenSnps=/test/" + tarball_prefix + ".bgen.stats.gz"
    run_cmd(cmd, True)


# Run rare variant association testing using REGENIE (WARNING: DEPRECATED)
def regenie(tarball_prefix: str, pheno_name: str, is_binary: bool) -> None:

    # Run initial model fitting for REGNIE
    cmd = "regenie " \
          "--step 1 " \
          "--threads 16 " \
          "--bed /test/genetics/UKBB_200K_Autosomes_QCd " \
          "--exclude /test/genetics/UKBB_200K_Autosomes_QCd.low_MAC.snplist " \
          "--remove /test/MODEL_exclude.txt " \
          "--covarFile /test/covariates.formatted.txt " \
          "--covarColList age,sex,PC{1:10} " \
          "--catCovarList batch " \
          "--maxCatLevels 110 " \
          "--phenoFile /test/phenotypes.formatted.txt " \
          "--phenoCol " + pheno_name + " " \
          "--bsize 100 " \
          "--out /test/regenie_fit " \
          "--lowmem "
    if is_binary:
        cmd = cmd + "--bt"
    else:
        cmd = cmd + "--qt"
    run_cmd(cmd, True)

    # Now run actual fit:
    cmd = "./regenie " \
          "--step 2 " \
          "--threads 16 " \
          "--pgen /test/" + tarball_prefix + ".REGENIE " \
          "--remove /test/MODEL_exclude.txt " \
          "--covarFile /test/covariates.formatted.txt " \
          "--phenoFile /test/phenotypes.formatted.txt " \
          "--firth --approx " \
          "--pred /test/regenie_fit.list " \
          "--ano-file /test/" + tarball_prefix + ".REGENIE.annotation " \
          "--set-list /test/" + tarball_prefix + ".REGENIE.setfile " \
          "--mask-def /test/" + tarball_prefix + ".REGNIE.mask " \
          "--aaf-bins 1 " \
          "--write-mask " \
          "--bsize 200 " \
          "--out /test/regenie_fit_firth "
    if is_binary:
        cmd = cmd + "--bt"
    else:
        cmd = cmd + "--qt"
    run_cmd(cmd, True)


# Run rare variant association testing using SAIGE-GENE
def saige(tarball_prefix: str, pheno_name: str, is_binary: bool, sex: int) -> None:

    # See the README.md for more information on these parameters
    cmd = "step1_fitNULLGLMM.R " \
          "--plinkFile=/test/genetics/UKBB_200K_Autosomes_QCd_WBA " \
          "--phenoFile=/test/phenotypes_covariates.formatted.txt " \
          "--phenoCol=" + pheno_name + " " \
          "--isCovariateTransform=FALSE " \
          "--sampleIDColinphenoFile=IID " \
          "--outputPrefix=/test/SAIGE_OUT " \
          "--outputPrefix_varRatio=/test/SAIGE_OUT_cate " \
          "--sparseGRMFile=/test/genetics/sparseGRM_200K_Autosomes_QCd_relatednessCutoff_0.125_2000_randomMarkersUsed.sparseGRM.mtx " \
          "--sparseGRMSampleIDFile=/test/genetics/sparseGRM_200K_Autosomes_QCd_relatednessCutoff_0.125_2000_randomMarkersUsed.sparseGRM.mtx.sampleIDs.txt " \
          "--nThreads=32 " \
          "--LOCO=FALSE " \
          "--skipModelFitting=FALSE " \
          "--IsSparseKin=TRUE " \
          "--isCateVarianceRatio=TRUE "
    if sex == 2:
        cmd = cmd + "--covarColList=PC1,PC2,PC3,PC4,PC5,PC6,PC7,PC8,PC9,PC10,age,sex "
    else:
        cmd = cmd + "--covarColList=PC1,PC2,PC3,PC4,PC5,PC6,PC7,PC8,PC9,PC10,age "
    if is_binary:
        cmd = cmd + "--traitType=binary"
    else:
        cmd = cmd + "--traitType=quantitative"
    run_cmd(cmd, True)

    # Need to pare down tested samples to those in the covariate file using bcftools:
    cmd = "bcftools view -S /test/SAMPLES_Include.txt -Oz -o /test/saige_input.vcf.gz /test/PTV.SAIGE.vcf.gz"
    run_cmd(cmd, True)
    cmd = "bcftools index /test/saige_input.vcf.gz"
    run_cmd(cmd, True)

    # See the README.md for more information on these parameters
    cmd = "step2_SPAtests.R " \
          "--vcfFile=/test/saige_input.vcf.gz " \
          "--vcfField=GT " \
          "--GMMATmodelFile=/test/SAIGE_OUT.rda " \
          "--varianceRatioFile=/test/SAIGE_OUT_cate.varianceRatio.txt " \
          "--LOCO=FALSE " \
          "--SAIGEOutputFile=/test/" + tarball_prefix + ".SAIGE_OUT.SAIGE.gene.txt " \
          "--groupFile=/test/" + tarball_prefix + ".SAIGE.groupFile.txt " \
          "--sparseSigmaFile=/test/SAIGE_OUT_cate.varianceRatio.txt_relatednessCutoff_0.125_2000_randomMarkersUsed.sparseSigma.mtx " \
          "--IsSingleVarinGroupTest=TRUE " \
          "--MACCutoff_to_CollapseUltraRare=0.5 " \
          "--IsOutputBETASEinBurdenTest=TRUE"
    run_cmd(cmd, True)


# Run rare variant association testing using STAAR
def staar(tarball_prefix: str, pheno_name: str, is_binary: bool) -> None:

    # I have made a custom script in order to run STAAR:
    # located in /usr/bin/runSTAAR.R
    # This generates a text output file of p.values
    # See the README.md for more information on these parameters
    cmd = "Rscript /prog/runSTAAR.R " \
          "/test/" + tarball_prefix + ".STAAR.matrix.rds " \
          "/test/" + tarball_prefix + ".variants_table.STAAR.tsv " \
          "/test/" + tarball_prefix + ".REGENIE.annotation " \
          "/test/phenotypes_covariates.formatted.txt " + \
          pheno_name + " " + \
          tarball_prefix + " " + \
          str(is_binary)
    run_cmd(cmd, True)


#Run rare variant association testing using GLMs
def linear_model(tarball_prefix, pheno_name, is_binary):

    # load covariates and phenotypes
    pheno_covars = pd.read_csv("phenotypes_covariates.formatted.txt",
                               sep=" ",
                               index_col="FID",
                               dtype={'IID':str})
    pheno_covars.index = pheno_covars.index.astype(str)
    poss_indv = set(pheno_covars.index.to_list())

    # load genes we need to test:
    genes_to_include = open(tarball_prefix + '.REGENIE.inclusion', 'r')
    genes = []
    for gene in genes_to_include:
        genes.append(gene.rstrip())
    genes_to_include.close()

    # load genetic data
    # first convert into format we can use:
    cmd = "plink2 --bgen /test/" + tarball_prefix + ".BOLT.bgen 'ref-last' --export bcf --out /test/lm"
    run_cmd(cmd, True)
    # This just makes a sparse matrix with columns: sample_id, gene name, genotype
    cmd = "bcftools query -i \"GT='alt'\" -f \"[%SAMPLE\t%ID\t%GT\n]\" /test/lm.bcf > lm.tsv"
    run_cmd(cmd, True)
    geno_table = pd.read_csv("lm.tsv",
                             sep = "\t",
                             names = ['eid', 'gene', 'gt'])
    # VCF stores samples in eid_eid format, so get just the first eid
    geno_table[['eid','eid2']] = geno_table['eid'].str.split('_', 1, expand=True)
    geno_table = geno_table.drop('eid2', axis=1)

    # Get individuals to include
    cmd = "bcftools query -l /test/lm.bcf > samples_lm.txt"
    run_cmd(cmd, True)
    samples_to_include = open('samples_lm.txt', 'r')
    includes = []
    for id in samples_to_include:
        id = id.rstrip().split("_")[0]
        if id in poss_indv:
            includes.append(id)
    samples_to_include.close()

    # include only WES samples from the covariates table:
    pheno_covars = pheno_covars.loc[includes]

    # Now successively iterate through each gene and run our model:
    # I think this is straight forward?
    results_dict = {} #This makes a dictionary for us to store each gene
    if is_binary:
        family = sm.families.Binomial()
    else:
        family = sm.families.Gaussian()
    for gene in genes:
        indv_w_var = geno_table.loc[geno_table['gene'] == gene]['eid'].to_list()
        pheno_covars['has_var'] = np.where(pheno_covars.index.isin(indv_w_var), 1, 0)
        n_car = len(pheno_covars.loc[pheno_covars['has_var'] == 1])
        if n_car <= 2:
            results_dict[gene] = {'p_val': 'NA',
                                  'effect': 'NA',
                                  'std_err': 'NA',
                                  'n_car': n_car,
                                  'n_model': len(pheno_covars),
                                  'gene': gene}
        else:
            sm_results = sm.GLM.from_formula(pheno_name + ' ~ has_var + sex + age + batch + PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10', data=pheno_covars, family=family).fit()
            results_dict[gene] = {'p_val': sm_results.pvalues['has_var'],
                                  'effect': sm_results.params['has_var'],
                                  'std_err': sm_results.bse['has_var'],
                                  'n_car': n_car,
                                  'n_model': sm_results.nobs,
                                  'gene': gene}

    # Write results:
    lm_stats_file = open(tarball_prefix + ".lm_stats.tsv", 'w')
    lm_stats_writer = csv.DictWriter(lm_stats_file, delimiter = "\t", fieldnames=['gene','p_val','effect','std_err','n_car','n_model'])
    lm_stats_writer.writeheader()
    for gene in results_dict:
        lm_stats_writer.writerow(results_dict[gene])

    lm_stats_file.close()


@dxpy.entry_point('main')
def main(association_tarball, run_bolt, run_staar, run_regenie, run_saige, run_linear_model, is_binary, sex, phenofile, output_prefix):

    # To-dos:
    # 1. Make some sort of smart thread-setter...
    # 2. Add ability to modify input covariates (static at the moment)

    if run_bolt is False and run_staar is False and run_regenie is False and run_saige is False and run_linear_model is False:
        raise Exception("No models were selected for execution!")

    # Bring our docker image into our environment so that we can run commands we need:
    cmd = "docker pull egardner413/mrcepid-associationtesting:latest"
    run_cmd(cmd)

    # Grab the data necessary to run this:
    tarball_prefix = ingest_data(association_tarball, phenofile)

    # This does covariate processing for all pipelines regardless of what we need to run
    # Also returns the phenotype name we are going to test
    pheno_name = process_covariates(sex)
    print("Phenotype: " + pheno_name)

    # Run models that were selected
    output_files = [] # Create a list of outputs to drop into the tarball later
    if run_bolt:
        print("Running BOLT")
        bolt(tarball_prefix, pheno_name)
        output_files.append(tarball_prefix + ".stats.gz")
        output_files.append(tarball_prefix + ".bgen.stats.gz")
    if run_regenie:
        print("Running REGENIE")
        regenie(tarball_prefix, pheno_name, is_binary)
        output_files.append(tarball_prefix + ".regenie_fit_firth_LOY_combined.regenie")
    if run_saige:
        print("Running SAIGE")
        saige(tarball_prefix, pheno_name, is_binary, sex)
        output_files.append(tarball_prefix + ".SAIGE_OUT.SAIGE.gene.txt")
        output_files.append(tarball_prefix + ".SAIGE_OUT.SAIGE.gene.txt_single")
    if run_staar:
        print("Running STAAR")
        staar(tarball_prefix, pheno_name, is_binary)
        output_files.append(tarball_prefix + ".STAAR_results.tsv")
    if run_linear_model:
        print("Running a Linear Model")
        linear_model(tarball_prefix, pheno_name, is_binary)
        output_files.append(tarball_prefix + ".lm_stats.tsv")

    # Create tar of all possible output files
    if output_prefix is None:
        output_tarball = "assoc_stats.tar.gz"
    else:
        output_tarball = output_prefix + ".assoc_stats.tar.gz"

    tar = tarfile.open(output_tarball, "w:gz")
    for file in output_files:
        tar.add(file)
    tar.close()

    ## Have to do 'upload_local_file' to make sure the new file is registered with dna nexus
    output = {"output_tarball": dxpy.dxlink(dxpy.upload_local_file(output_tarball))}

    return output


dxpy.run()
